// Code generated by schema-generate. DO NOT EDIT.

package test

import (
    "fmt"
    "encoding/json"
    "bytes"
    "reflect"
)

// AdditionalProperties 
type AdditionalProperties struct {
  Property1 string `json:"property1,omitempty"`
  Property2 *Address `json:"property2,omitempty"`
  Property3 *Property3 `json:"property3,omitempty"`
  Property4 *Property4 `json:"property4,omitempty"`
  Property5 *Property5 `json:"property5,omitempty"`
  Property6 *Property6 `json:"property6,omitempty"`
  Property7 *Property7 `json:"property7,omitempty"`
}

// Address 
type Address struct {
  City string `json:"city,omitempty"`
}

// Anonymous1 
type Anonymous1 struct {
  Color string `json:"color,omitempty"`
  Conditions []*ConditionsItems `json:"conditions,omitempty"`
  Density float64 `json:"density,omitempty"`
}

// ConditionsItems 
type ConditionsItems struct {
  Name string `json:"name,omitempty"`
}

// NotSoAnonymous 
type NotSoAnonymous struct {
  Subproperty1 int `json:"subproperty1,omitempty"`
}

// PoBox 
type PoBox struct {
  Suburb string `json:"suburb,omitempty"`
}

// Property3 
type Property3 struct {
  AdditionalProperties map[string]int `json:"-,omitempty"`
  Age int `json:"age,omitempty"`
}

// Property4 
type Property4 struct {
  AdditionalProperties map[string]string `json:"-,omitempty"`
  Age int `json:"age,omitempty"`
}

// Property5 
type Property5 struct {
  AdditionalProperties map[string]*NotSoAnonymous `json:"-,omitempty"`
  Age int `json:"age,omitempty"`
}

// Property6 
type Property6 struct {
  AdditionalProperties map[string]*Property6Item `json:"-,omitempty"`
  Age int `json:"age,omitempty"`
  Pronoun string `json:"pronoun,omitempty"`
}

// Property6Item 
type Property6Item struct {
  Subproperty1 int `json:"subproperty1,omitempty"`
}

// Property7 
type Property7 struct {
  AdditionalProperties map[string]map[string]*Anonymous1 `json:"-,omitempty"`
  PoBox *PoBox `json:"po_box,omitempty"`
  StreetName string `json:"street_name,omitempty"`
  StreetNumber int `json:"street_number,omitempty"`
}

func (strct *Property3) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "age" field
	if reflect.TypeOf(strct.Age) != nil && (reflect.TypeOf(strct.Age).Kind() == reflect.Bool || !reflect.DeepEqual(strct.Age, reflect.Zero(reflect.TypeOf(strct.Age)).Interface())) {
		if comma { 
			buf.WriteString(",") 
		}
		buf.WriteString("\"age\": ")
		if tmp, err := json.Marshal(strct.Age); err != nil {
			return nil, err
		} else {
			buf.Write(tmp)
		}
		comma = true
	}
    // Marshal any additional Properties
    for k, v := range strct.AdditionalProperties {
		if comma {
			buf.WriteString(",")
		}
        buf.WriteString(fmt.Sprintf("\"%s\":", k))
		if tmp, err := json.Marshal(v); err != nil {
			return nil, err
		} else {
			buf.Write(tmp)
		}
        comma = true
	}

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Property3) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "age":
            if err := json.Unmarshal([]byte(v), &strct.Age); err != nil {
                return err
             }
        default:
            // an additional "int" value
            var additionalValue int
            if err := json.Unmarshal([]byte(v), &additionalValue); err != nil {
                return err // invalid additionalProperty
            }
            if strct.AdditionalProperties == nil {
                strct.AdditionalProperties = make(map[string]int, 0)
            }
            strct.AdditionalProperties[k]= additionalValue
        }
    }
    return nil
}

func (strct *Property4) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "age" field
	if reflect.TypeOf(strct.Age) != nil && (reflect.TypeOf(strct.Age).Kind() == reflect.Bool || !reflect.DeepEqual(strct.Age, reflect.Zero(reflect.TypeOf(strct.Age)).Interface())) {
		if comma { 
			buf.WriteString(",") 
		}
		buf.WriteString("\"age\": ")
		if tmp, err := json.Marshal(strct.Age); err != nil {
			return nil, err
		} else {
			buf.Write(tmp)
		}
		comma = true
	}
    // Marshal any additional Properties
    for k, v := range strct.AdditionalProperties {
		if comma {
			buf.WriteString(",")
		}
        buf.WriteString(fmt.Sprintf("\"%s\":", k))
		if tmp, err := json.Marshal(v); err != nil {
			return nil, err
		} else {
			buf.Write(tmp)
		}
        comma = true
	}

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Property4) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "age":
            if err := json.Unmarshal([]byte(v), &strct.Age); err != nil {
                return err
             }
        default:
            // an additional "string" value
            var additionalValue string
            if err := json.Unmarshal([]byte(v), &additionalValue); err != nil {
                return err // invalid additionalProperty
            }
            if strct.AdditionalProperties == nil {
                strct.AdditionalProperties = make(map[string]string, 0)
            }
            strct.AdditionalProperties[k]= additionalValue
        }
    }
    return nil
}

func (strct *Property5) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "age" field
	if reflect.TypeOf(strct.Age) != nil && (reflect.TypeOf(strct.Age).Kind() == reflect.Bool || !reflect.DeepEqual(strct.Age, reflect.Zero(reflect.TypeOf(strct.Age)).Interface())) {
		if comma { 
			buf.WriteString(",") 
		}
		buf.WriteString("\"age\": ")
		if tmp, err := json.Marshal(strct.Age); err != nil {
			return nil, err
		} else {
			buf.Write(tmp)
		}
		comma = true
	}
    // Marshal any additional Properties
    for k, v := range strct.AdditionalProperties {
		if comma {
			buf.WriteString(",")
		}
        buf.WriteString(fmt.Sprintf("\"%s\":", k))
		if tmp, err := json.Marshal(v); err != nil {
			return nil, err
		} else {
			buf.Write(tmp)
		}
        comma = true
	}

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Property5) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "age":
            if err := json.Unmarshal([]byte(v), &strct.Age); err != nil {
                return err
             }
        default:
            // an additional "*NotSoAnonymous" value
            var additionalValue *NotSoAnonymous
            if err := json.Unmarshal([]byte(v), &additionalValue); err != nil {
                return err // invalid additionalProperty
            }
            if strct.AdditionalProperties == nil {
                strct.AdditionalProperties = make(map[string]*NotSoAnonymous, 0)
            }
            strct.AdditionalProperties[k]= additionalValue
        }
    }
    return nil
}

func (strct *Property6) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "age" field
	if reflect.TypeOf(strct.Age) != nil && (reflect.TypeOf(strct.Age).Kind() == reflect.Bool || !reflect.DeepEqual(strct.Age, reflect.Zero(reflect.TypeOf(strct.Age)).Interface())) {
		if comma { 
			buf.WriteString(",") 
		}
		buf.WriteString("\"age\": ")
		if tmp, err := json.Marshal(strct.Age); err != nil {
			return nil, err
		} else {
			buf.Write(tmp)
		}
		comma = true
	}
    // Marshal the "pronoun" field
	if reflect.TypeOf(strct.Pronoun) != nil && (reflect.TypeOf(strct.Pronoun).Kind() == reflect.Bool || !reflect.DeepEqual(strct.Pronoun, reflect.Zero(reflect.TypeOf(strct.Pronoun)).Interface())) {
		if comma { 
			buf.WriteString(",") 
		}
		buf.WriteString("\"pronoun\": ")
		if tmp, err := json.Marshal(strct.Pronoun); err != nil {
			return nil, err
		} else {
			buf.Write(tmp)
		}
		comma = true
	}
    // Marshal any additional Properties
    for k, v := range strct.AdditionalProperties {
		if comma {
			buf.WriteString(",")
		}
        buf.WriteString(fmt.Sprintf("\"%s\":", k))
		if tmp, err := json.Marshal(v); err != nil {
			return nil, err
		} else {
			buf.Write(tmp)
		}
        comma = true
	}

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Property6) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "age":
            if err := json.Unmarshal([]byte(v), &strct.Age); err != nil {
                return err
             }
        case "pronoun":
            if err := json.Unmarshal([]byte(v), &strct.Pronoun); err != nil {
                return err
             }
        default:
            // an additional "*Property6Item" value
            var additionalValue *Property6Item
            if err := json.Unmarshal([]byte(v), &additionalValue); err != nil {
                return err // invalid additionalProperty
            }
            if strct.AdditionalProperties == nil {
                strct.AdditionalProperties = make(map[string]*Property6Item, 0)
            }
            strct.AdditionalProperties[k]= additionalValue
        }
    }
    return nil
}

func (strct *Property7) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "po_box" field
	if reflect.TypeOf(strct.PoBox) != nil && (reflect.TypeOf(strct.PoBox).Kind() == reflect.Bool || !reflect.DeepEqual(strct.PoBox, reflect.Zero(reflect.TypeOf(strct.PoBox)).Interface())) {
		if comma { 
			buf.WriteString(",") 
		}
		buf.WriteString("\"po_box\": ")
		if tmp, err := json.Marshal(strct.PoBox); err != nil {
			return nil, err
		} else {
			buf.Write(tmp)
		}
		comma = true
	}
    // Marshal the "street_name" field
	if reflect.TypeOf(strct.StreetName) != nil && (reflect.TypeOf(strct.StreetName).Kind() == reflect.Bool || !reflect.DeepEqual(strct.StreetName, reflect.Zero(reflect.TypeOf(strct.StreetName)).Interface())) {
		if comma { 
			buf.WriteString(",") 
		}
		buf.WriteString("\"street_name\": ")
		if tmp, err := json.Marshal(strct.StreetName); err != nil {
			return nil, err
		} else {
			buf.Write(tmp)
		}
		comma = true
	}
    // Marshal the "street_number" field
	if reflect.TypeOf(strct.StreetNumber) != nil && (reflect.TypeOf(strct.StreetNumber).Kind() == reflect.Bool || !reflect.DeepEqual(strct.StreetNumber, reflect.Zero(reflect.TypeOf(strct.StreetNumber)).Interface())) {
		if comma { 
			buf.WriteString(",") 
		}
		buf.WriteString("\"street_number\": ")
		if tmp, err := json.Marshal(strct.StreetNumber); err != nil {
			return nil, err
		} else {
			buf.Write(tmp)
		}
		comma = true
	}
    // Marshal any additional Properties
    for k, v := range strct.AdditionalProperties {
		if comma {
			buf.WriteString(",")
		}
        buf.WriteString(fmt.Sprintf("\"%s\":", k))
		if tmp, err := json.Marshal(v); err != nil {
			return nil, err
		} else {
			buf.Write(tmp)
		}
        comma = true
	}

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Property7) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "po_box":
            if err := json.Unmarshal([]byte(v), &strct.PoBox); err != nil {
                return err
             }
        case "street_name":
            if err := json.Unmarshal([]byte(v), &strct.StreetName); err != nil {
                return err
             }
        case "street_number":
            if err := json.Unmarshal([]byte(v), &strct.StreetNumber); err != nil {
                return err
             }
        default:
            // an additional "map[string]*Anonymous1" value
            var additionalValue map[string]*Anonymous1
            if err := json.Unmarshal([]byte(v), &additionalValue); err != nil {
                return err // invalid additionalProperty
            }
            if strct.AdditionalProperties == nil {
                strct.AdditionalProperties = make(map[string]map[string]*Anonymous1, 0)
            }
            strct.AdditionalProperties[k]= additionalValue
        }
    }
    return nil
}

